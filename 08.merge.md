merge?
===
브랜치를 나누어 작업하다보면 브랜치간 작업 상황이 달라질 수 있다. 미완성이거나 개발에 실패한 브랜치가 아니라면 모든 브랜치는 하나로 합쳐져야 의미가 있다. 이 과정이 merge다.

병합은 '두' 개의 커밋을 합치는 과정이다.

모든 커밋은 자신의 부모커밋을 기록하고 있다. 커밋 내역이

      INIT -> C1 -> C2 -> C3
라고 할 때, C3는 C2를 알고 있고, C2는 C1을 알고 있다.

따라서, 브랜치가 어디서 갈라지던, 공통 부모는 존재한다. 이 공통 부모와 합치려는 두 커밋을 활용하여 merge가 된다.

병합하기
---
      git merge <branch_name>
이는, 현재 브랜치를 기준으로 <branch_name>을 병합하는 것이다. 현재 브랜치를 <branch_name>에 병합하는 것이 아니다.

master 브랜치가 메인 브랜치이고, 기능을 추가하고자 dev1 브랜치를 만들어서 기능을 추가가 완료되었고, 이를 master에 반영하고 싶다면 우선 master 브랜치로 이동한 후에

      git checkout master
dev1을 병합한다.

      git merge dev1  
개발이 완료된 dev1을 더 유지할 이유가 없다면, 삭제한다.

      git branch -d dev1
추가 기능이 필요하면, 다시 새로운 브랜치를 만들어서 시작하면 된다.

병합의 두 가지 방식
---
#### fast-forward 병합
아래와 같은 커밋 내역이 있을 때,

      INIT -> M1 -> M2 (master)
                     ↓
                    B1 -> B2 (dev1)
브랜치는 두 개지만, 사실상 하나의 작업이 선형으로 이루어진 구조이다. 이 경우에 병합을 하면 master 브랜치가 B2 커밋을 가리키는 것으로 병합이 끝난다. 충돌도 없고, 커밋도 없다.

#### 3-way merge
master 브랜치의 M3 커밋으로부터 갈라져 나와서 login 기능을 개발하는 브랜치와 그 login 브랜치에서 갈라진 naver-login 브랜치가 있다고 하자. naver-login 은 login에 합쳐져야하고, login은 다시 master에 병합되어야한다.

커밋 내역은 아래와 같다.

      M3 -> L1 -> L2 (login)
             ↓
            N1 -> N2 (naver-login)

login 브랜치로 이동하여

      git checkout login
naver-login 브랜치를 병합한다.

      git merge naver-login

이 때, git은 다음과 같이 L3 커밋을 새로 생성하려고 시도한다.

      M3 -> L1 -> L2 -> L3 (login)
             ↓
            N1 -> N2 (naver-login)
naver-login 브랜치에는 변화가 없다. 이 것은 login 브랜치에서 하는 작업이므로 login 브랜치가 변하는 것이다.

fast-forward 방식과 다르게, 이 과정은 커밋이 하나 더 생긴다. 커밋이므로 커밋 메세지가 필요하다. 커밋메세지는 "naver-login을 login에 병합함" 정도로 작성하면 된다.

병합 충돌
---
fast-forward 방식에서는 문제가 없지만, 3way-merge 에서는 종종 충돌이 발생한다. 두 브랜치에서 같은 파일에 대한 변경사항이 발생하면 git은 둘 중 어느 파일의 내용이 맞는것인지 스스로 판단하지 못한다. 따라서 병합이 잠시 중단된다.

병합이 중단되는 지점은 다음과 같다.

      git merge naver-login

충돌이 발생하지 않은 파일들은 그대로 워킹트리에 준비해두고, 충돌이 발생한 파일들은 충돌이 일어난 내용을 비교하여 두 내용 모두를 포함한 상태로 준비해둔다.

상태를 확인해보자

      git status
그러면

      both modified: <file_name>
위와 같은 결과를 볼 수 있다. 이 파일들이 충돌이 난 파일들이다.

충돌이 발생한 파일을 열어보면,

      <<<<<<< HEAD
      login의 내용
      =======
      naver-login의 내용
      >>>>>>> naver-login

같은 내용이 들어있는데, HEAD는 병합을 수행하려는 현재 브랜치에서의 파일 내용이며, ======= 다음 줄부터 나오는 내용은 병합 대상이 되는 브랜치의 내용이다.

이 충돌 내역을 적절히 수정해서 올바른 파일로 만든후 다시 파일을 저장하고,

      git add <file_name>
      git commit
으로 커밋하면 병합이 완료된다.

이 과정은 merge가 아니고 commit이다. merge는

      git merge naver-login
명령을 내린 시점에 준비가 된 것이고, commit을 하기 직전에 사용자에게 충돌 사실을 알리고 잠시 멈춘것 뿐이다.

기능적으로는 충돌난 파일을 무시하고 'both modified' 상태에서 곧바로 git add . && git commit 해도 된다. 하지만, 파일의 내용은 정상이 아닐것이다.

어떤 내용을 적용해야할 지 알기 어렵다면, 그대로 커밋해버리고 해결은 다른사람이 하도록 맡기는 방식도 고려해 볼 수 있다. 단, 커밋메세지를 잘 작성해두어야 한다.